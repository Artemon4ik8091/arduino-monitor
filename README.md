
# Информационный Дисплей на Arduino и Python

Этот проект представляет собой систему, которая отображает различную информацию (системные показатели, сетевые данные, погоду, статус Яндекс.Музыки) на LCD-дисплее, подключенном к Arduino, управляемом Python-скриптом, запущенным на мини-ПК (например, Raspberry Pi).

## 1\. Обзор Проекта

Проект состоит из двух основных частей, тесно взаимодействующих по последовательному порту:

  * **Python-скрипт (на мини-ПК):** Отвечает за сбор данных из различных источников (системные ресурсы, сетевая информация, OpenWeatherMap API, Яндекс.Музыка API) и отправку их по последовательному порту на Arduino. Он также выполняет транслитерацию русского текста для корректного отображения на LCD.
  * **Arduino-скетч (на микроконтроллере):** Получает данные по последовательному порту от Python-скрипта, обрабатывает нажатия кнопок, управляет логикой отображения информации на LCD-дисплее и отправляет команды обратно на Python-скрипт.

## 2\. Python-скрипт

### 2.1. Назначение

Python-скрипт является "мозгом" системы. Он выполняет следующие функции:

  * **Сбор системных метрик:** Процент загрузки CPU, использование RAM, использование диска.
  * **Получение сетевой информации:** SSID Wi-Fi сети и IP-адрес.
  * **Запрос данных о погоде:** Получает текущую погоду и температуру с OpenWeatherMap API.
  * **Мониторинг Яндекс.Музыки:** Получает информацию о текущем воспроизводимом треке (исполнитель, название), его статусе (играет/пауза) с помощью Яндекс.Музыки API.
  * **Транслитерация:** Преобразует русские символы в латиницу для совместимости с LCD-дисплеем, поскольку большинство таких дисплеев не поддерживают кириллицу напрямую.
  * **Форматирование данных:** Подготавливает строки данных для вывода на 16-символьный 2-строчный LCD.
  * **Последовательная связь:** Отправляет отформатированные данные на Arduino по последовательному порту.
  * **Обработка команд от Arduino:** Слушает команды от Arduino (например, запросы на обновление погоды или системных данных) и реагирует на них, отправляя запрашиваемые данные.
  * **Режимы отображения:** Автоматически переключает режимы отображения на LCD в зависимости от статуса воспроизведения Яндекс.Музыки:
      * **Режим "Музыка играет":** На первой строке компактная дата/время и температура, на второй – прокручиваемое название трека/исполнителя (транслитерированное).
      * **Режим "Ожидание" (музыка не играет или на паузе):** На первой строке полная дата/время, на второй – информация о погоде.

### 2.2. Зависимости

Для работы Python-скрипта необходимо установить следующие библиотеки:

  * `pyserial`: Для взаимодействия с последовательным портом (Arduino).
  * `psutil`: Для получения системных метрик.
  * `requests`: Для HTTP-запросов к OpenWeatherMap API.
  * `aiohttp`: Для асинхронных HTTP-запросов (используется библиотекой yandex-music).
  * `yandex-music`: Для взаимодействия с Яндекс.Музыкой API.

Вы можете установить их с помощью `pip`:

```bash
pip install pyserial psutil requests aiohttp yandex-music
```

### 2.3. Конфигурация

Перед запуском скрипта необходимо настроить следующие параметры в файле `display_controller.py`:

  * **`arduino_port`**: Строка, указывающая на последовательный порт, к которому подключен Arduino. Для Linux это часто `/dev/ttyACM0` или `/dev/ttyUSB0`.
  * **`baud_rate`**: Скорость передачи данных по последовательному порту. Должна совпадать со скоростью, установленной в Arduino-скетче (по умолчанию 9000).
  * **`OPENWEATHER_API_KEY`**: Ваш API-ключ для OpenWeatherMap. Получить его можно после регистрации на [OpenWeatherMap](https://openweathermap.org/api).
  * **`CITY_ID`**: ID вашего города для OpenWeatherMap. Вы можете найти его в файле со списком городов.
  * **`YANDEX_MUSIC_TOKEN`**: Ваш авторизационный токен для Яндекс.Музыки. Инструкции по его получению можно найти здесь: [Получение токена Яндекс.Музыки](https://github.com/MarshalX/yandex-music-api/discussions/513#discussioncomment-2729781).
  * **`MUSIC_API_CHECK_INTERVAL_SEC`**: Интервал в секундах, с которым скрипт будет опрашивать API Яндекс.Музыки для обновления статуса трека.
  * **`MUSIC_SCROLL_SPEED_SEC`**: Интервал в секундах, с которым будет происходить смещение текста при прокрутке названия трека. Меньшее значение = более быстрая прокрутка (например, `0.2` для быстрой прокрутки).
  * **`WEATHER_UPDATE_INTERVAL_MINUTES`**: Интервал в минутах, с которым будет обновляться информация о погоде.
  * **`IDLE_DATA_SEND_INTERVAL_SEC`**: Интервал в секундах, с которым данные будут отправляться на Arduino в режиме ожидания (для поддержания актуальности экрана).

**Пример конфигурации в коде:**

```python
arduino_port = "/dev/ttyACM0" 
baud_rate = 9000               

OPENWEATHER_API_KEY = "ВАШ_API_КЛЮЧ_ЗДЕСЬ"  
CITY_ID = "ВАШ_ID_ГОРОДА"                                   

YANDEX_MUSIC_TOKEN = "ВАШ_ЯНДЕКС_МУЗЫКА_ТОКЕН_ЗДЕСЬ" 
MUSIC_API_CHECK_INTERVAL_SEC = 5 
MUSIC_SCROLL_SPEED_SEC = 0.2 
```

### 2.4. Ссылка на файл со всеми ID городов OpenWeatherMap

Список всех городов и их ID, используемых в OpenWeatherMap API, доступен для загрузки:

  * [Список городов OpenWeatherMap (JSON, GZ-архив)](https://www.google.com/search?q=https://bulk.openweathermap.org/sample/city.list.json.gz)

Вы можете загрузить этот файл, распаковать его (например, с помощью `gunzip` в Linux или любого архиватора) и найти ID своего города, используя поиск по названию.

### 2.5. Основные функции и логика

  * **`transliterate_cyrillic(text)`**: Преобразует символы кириллицы в латинские эквиваленты.
  * **`get_current_time_and_date_full()`**: Возвращает полную строку с датой и временем (ДД/ММ/ГГ ЧЧ:ММ) для режима ожидания.
  * **`get_current_time_and_date_compact()`**: Возвращает компактную дату (ДД/ММ) и время (ЧЧ:ММ) для режима воспроизведения музыки.
  * **`update_weather_data_func()`**: Запрашивает и обновляет данные о погоде с OpenWeatherMap.
  * **`get_weather_line_for_display()`**: Форматирует строку погоды для вывода на дисплей.
  * **`get_current_track_ym(client_ym, token)`**: Асинхронная функция, которая взаимодействует с Яндекс.Музыкой API для получения информации о текущем треке, включая статус паузы.
  * **`music_status_update_task()`**: Асинхронная задача, которая периодически опрашивает Яндекс.Музыку, обрабатывает полученные данные (включая транслитерацию) и управляет состоянием прокрутки текста.
  * **`arduino_communication_task()`**: Асинхронная задача, которая отвечает за отправку данных на Arduino и прием команд от него. В этой задаче происходит основная логика переключения режимов отображения (`is_playing` или `is_paused`).
  * **`weather_update_task()`**: Асинхронная задача, которая периодически обновляет данные о погоде.
  * **`main()`**: Главная асинхронная функция, которая запускает все остальные асинхронные задачи параллельно.

### 2.6. Как запустить Python-скрипт

1.  **Сохраните код:** Сохраните предоставленный Python-код в файл, например, `display_controller.py`.

2.  **Настройте параметры:** Откройте файл `display_controller.py` и отредактируйте переменные конфигурации, как описано в разделе 2.3.

3.  **Запустите скрипт:** Откройте терминал на вашем мини-ПК, перейдите в директорию с файлом скрипта и запустите его:

    ```bash
    python3 display_controller.py
    ```

4.  **Фоновый режим (опционально):** Если вы хотите, чтобы скрипт работал в фоновом режиме после закрытия терминала, вы можете использовать `nohup` или `screen`/`tmux`:

    ```bash
    nohup python3 display_controller.py &
    ```

    Или

    ```bash
    screen -S display_app
    python3 display_controller.py
    # Затем нажмите Ctrl+A, затем D, чтобы отсоединиться от сессии screen
    ```

    Чтобы снова присоединиться к сессии `screen`, используйте `screen -r display_app`.

## 3\. Arduino-скетч (`arduino_monitor.ino`)

Arduino-скетч отвечает за низкоуровневое взаимодействие с LCD-дисплеем и кнопками, а также за обработку данных, поступающих от Python-скрипта.

### 3.1. Необходимые библиотеки

[cite\_start]Для работы данного скетча требуется библиотека `LiquidCrystal.h`. [cite: 1] Она обычно входит в стандартный комплект Arduino IDE.

### 3.2. Подключение аппаратной части

  * **LCD-дисплей:**
      * [cite\_start]`RS` пин подключен к пину `12` Arduino. [cite: 1]
      * [cite\_start]`Enable` пин подключен к пину `11` Arduino. [cite: 1]
      * [cite\_start]`D4` пин подключен к пину `5` Arduino. [cite: 1]
      * [cite\_start]`D5` пин подключен к пину `4` Arduino. [cite: 1]
      * [cite\_start]`D6` пин подключен к пину `3` Arduino. [cite: 1]
      * [cite\_start]`D7` пин подключен к пину `2` Arduino. [cite: 1]
      * (Остальные соединения LCD, такие как VCC, GND, контрастность, подсветка, должны быть выполнены стандартным образом.)
  * **Кнопки:**
      * [cite\_start]Кнопка **A** (BUTTON\_A\_PIN) подключена к пину `6` Arduino. [cite: 2]
      * [cite\_start]Кнопка **B** (BUTTON\_B\_PIN) подключена к пину `7` Arduino. [cite: 2]
      * [cite\_start]Обе кнопки настроены как `INPUT_PULLUP`, что означает, что они подключены между пином и землей (GND). [cite: 15] Нажатие кнопки замыкает пин на землю, считывается как `LOW`.

### 3.3. Глобальные переменные и настройки

  * [cite\_start]**`LiquidCrystal lcd(12, 11, 5, 4, 3, 2);`**: Инициализация LCD-дисплея. [cite: 1]
  * [cite\_start]**`BUTTON_A_PIN = 6`**, **`BUTTON_B_PIN = 7`**: Пины, к которым подключены кнопки. [cite: 2]
  * [cite\_start]**`DEBOUNCE_DELAY = 50`**: Задержка для подавления дребезга контактов кнопок (в миллисекундах). [cite: 4]
  * [cite\_start]**`displayMode`**: Текущий режим отображения: [cite: 5]
      * [cite\_start]`0`: Режим ожидания (Дата/Время + Погода) [cite: 5]
      * [cite\_start]`1`: Режим прокрутки системной статистики (CPU/RAM/ROM -\> Network Info) [cite: 5]
  * [cite\_start]**`statsSubMode`**: Подрежим для прокрутки статистики, если `displayMode = 1`: [cite: 6]
      * [cite\_start]`0`: Показывает CPU/RAM/ROM. [cite: 6]
      * [cite\_start]`1`: Показывает Network Info. [cite: 6]
  * [cite\_start]**`CONNECTION_TIMEOUT = 4000`**: Таймаут для определения потери соединения с ПК (в миллисекундах, 4 секунды). [cite: 7, 8]
  * [cite\_start]**`WEATHER_UPDATE_INTERVAL_ARDUINO_MS = 15 * 60 * 1000`**: Интервал для автоматического запроса погоды с Arduino (15 минут). [cite: 11]
  * [cite\_start]**`SINGLE_CARD_DISPLAY_DURATION_MS = 5 * 1000`**: Длительность отображения каждой "карточки" статистики (системные данные или сетевые данные) перед переключением (5 секунд). [cite: 12]
  * [cite\_start]**Буферные строки**: Переменные для хранения последних полученных данных от Python-скрипта для различных режимов (`current_weather_line1/2`, `current_system_line1/2`, `current_network_line1/2`). [cite: 9, 10]

### 3.4. Функция `setup()`

Функция `setup()` выполняется один раз при старте Arduino:

1.  [cite\_start]**Инициализирует LCD-дисплей** (`lcd.begin(16, 2);`). [cite: 13]
2.  [cite\_start]**Выводит начальное сообщение** "Waiting for PC..." на LCD. [cite: 13]
3.  [cite\_start]**Инициализирует последовательный порт** (`Serial.begin(9000);`) для связи с ПК. [cite: 13] Скорость должна совпадать с Python-скриптом.
4.  [cite\_start]**Настраивает пины кнопок** как входы с подтягивающими резисторами (`pinMode(BUTTON_A_PIN, INPUT_PULLUP);`). [cite: 15]
5.  [cite\_start]**Инициализирует таймер** `last_data_received_time` текущим временем `millis()`. [cite: 14]
6.  [cite\_start]**Отправляет начальный запрос погоды** на ПК (`Serial.print("REQ_WEATHER\n");`). [cite: 14]

### 3.5. Функция `loop()`

Функция `loop()` выполняется непрерывно:

1.  [cite\_start]**Обработка кнопок:** [cite: 16, 23]
      * [cite\_start]**Кнопка A (`BUTTON_A_PIN`):** [cite: 16]
          * [cite\_start]В **режиме ожидания (`displayMode == 0`)**: Отправляет `REQ_WEATHER_FORCE` на ПК для принудительного обновления погоды. [cite: 18] [cite\_start]Очищает LCD и показывает "Updating weather". [cite: 19]
          * [cite\_start]В **режиме статистики (`displayMode == 1`)**: Возвращает `displayMode` в `0` (режим ожидания), сбрасывает `statsSubMode` в `0`. [cite: 20] [cite\_start]Если есть сохраненные данные погоды, отображает их; [cite: 20, 21] [cite\_start]иначе запрашивает погоду (`REQ_WEATHER`). [cite: 22]
      * [cite\_start]**Кнопка B (`BUTTON_B_PIN`):** [cite: 24]
          * [cite\_start]Если **не в режиме статистики (`displayMode != 1`)**: Переключает `displayMode` в `1` (режим статистики), сбрасывает `statsSubMode` в `0`. [cite: 26, 27, 28] [cite\_start]Отправляет `REQ_SYSTEM_STATS` на ПК для получения системных данных [cite: 29] [cite\_start]и запускает таймер для прокрутки статистики. [cite: 30] [cite\_start]Очищает LCD и показывает "Loading stats...". [cite: 31]
2.  [cite\_start]**Автоматический запрос погоды:** [cite: 32]
      * [cite\_start]Если Arduino находится в режиме ожидания (`displayMode == 0`) и прошло `WEATHER_UPDATE_INTERVAL_ARDUINO_MS` с последнего запроса, отправляет `REQ_WEATHER` на ПК. [cite: 33] [cite\_start]Очищает LCD и показывает "Updating weather". [cite: 34]
3.  [cite\_start]**Автоматическая прокрутка и возврат из режима статистики:** [cite: 34]
      * [cite\_start]Если Arduino находится в режиме статистики (`displayMode == 1`) и прошло `SINGLE_CARD_DISPLAY_DURATION_MS` с момента отображения текущей "карточки": [cite: 34]
          * [cite\_start]Переключает `statsSubMode` на следующую "карточку". [cite: 36]
          * [cite\_start]Если `statsSubMode` становится `1` (после CPU/RAM/ROM): Отправляет `REQ_NETWORK_INFO` на ПК. [cite: 37] [cite\_start]Очищает LCD и показывает "Loading network...". [cite: 38]
          * [cite\_start]Если `statsSubMode` переходит за пределы известных подрежимов (т.е., после сетевой информации): Возвращается в режим ожидания (`displayMode = 0`), сбрасывает `statsSubMode`. [cite: 39] [cite\_start]Отображает сохраненные данные погоды или запрашивает их. [cite: 40, 41]
4.  [cite\_start]**Обработка данных из последовательного порта:** [cite: 42]
      * Когда данные доступны в последовательном порту:
          * [cite\_start]Обновляет `last_data_received_time` для предотвращения срабатывания таймаута "Connection lost". [cite: 42]
          * [cite\_start]Считывает две строки данных, разделенные символом новой строки (`\n`). [cite: 44, 49]
          * **Если строки начинаются с "IDLE:"**: Это данные для режима ожидания (музыка играет или нет). [cite\_start]Удаляет префикс "IDLE:", сохраняет данные в `current_weather_line1/2` и, если текущий `displayMode == 0`, немедленно выводит их на LCD. [cite: 45, 46, 47, 48]
          * **Если строки не начинаются с "IDLE:"**: Это ответ на запросы (системные данные или сетевые данные).
              * [cite\_start]Если строка начинается с "CPU:", сохраняет как системные данные (`current_system_line1/2`) и выводит, если текущий `displayMode == 1` и `statsSubMode == 0`. [cite: 50, 51]
              * [cite\_start]Если строка начинается с "WIFI:", "No Network" или "Error cmd", сохраняет как сетевые данные (`current_network_line1/2`) и выводит, если `displayMode == 1` и `statsSubMode == 1`. [cite: 52, 53]
              * В противном случае (нет префикса "CPU:" или "WIFI:"), предполагается, что это ответ на запрос погоды (дата/время + погода). [cite\_start]Сохраняет в `current_weather_line1/2` и выводит, если `displayMode == 0`. [cite: 54, 55]
5.  [cite\_start]**Проверка таймаута соединения:** [cite: 56]
      * Если нет данных из последовательного порта в течение `CONNECTION_TIMEOUT`, Arduino считает, что соединение с ПК потеряно.
      * Очищает LCD и выводит "Connection lost\!" и "Check OrangePI." [cite\_start](или имя вашего мини-ПК). [cite: 56]
      * [cite\_start]Если соединение активно, но данных нет, и таймаут не превышен, то Arduino продолжает отображать последние известные данные в соответствии с текущим `displayMode` и `statsSubMode`. [cite: 58, 60, 61] [cite\_start]Если данных нет, то выводит "Waiting for data" или "Loading data...". [cite: 59, 62]

### 3.6. Как загрузить Arduino-скетч

1.  **Откройте Arduino IDE.**
2.  **Скопируйте содержимое файла `arduino_monitor.ino`** и вставьте его в новое окно скетча в Arduino IDE.
3.  **Подключите ваш Arduino** к компьютеру через USB.
4.  **Выберите правильную плату** (например, Arduino Uno) в меню `Инструменты > Плата`.
5.  **Выберите правильный порт** в меню `Инструменты > Порт`.
6.  **Нажмите кнопку "Загрузить"** (стрелка вправо) в Arduino IDE, чтобы скомпилировать и загрузить скетч на вашу плату Arduino.

-----